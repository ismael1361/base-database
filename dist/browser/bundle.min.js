(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PocketSafe=f()}})(function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Database=exports.Table=exports.Custom=exports.serializeData=exports.verifyDatatype=exports.getDatatype=exports.Types=exports.Operators=void 0;exports.Operators={EQUAL:"=",NOT_EQUAL:"!=",GREATER_THAN:">",LESS_THAN:"<",GREATER_THAN_OR_EQUAL:">=",LESS_THAN_OR_EQUAL:"<=",BETWEEN:"BETWEEN",LIKE:"LIKE",IN:"IN"};exports.Types={TEXT:"",INTEGER:0,FLOAT:.1,BOOLEAN:true,DATETIME:new Date,BIGINT:BigInt(0),NULL:null};const getDatatype=value=>{if(value===null)return"NULL";if(typeof value==="string")return"TEXT";if(typeof value==="bigint")return"BIGINT";if(typeof value==="number")return parseInt(value.toString()).toString()===value.toString()?"INTEGER":"FLOAT";if(typeof value==="boolean")return"BOOLEAN";if(value instanceof Date)return"DATETIME";return"TEXT"};exports.getDatatype=getDatatype;const verifyDatatype=(value,type)=>{switch(type){case"TEXT":return typeof value==="string";case"INTEGER":return parseInt(value)===value;case"FLOAT":return parseFloat(value)===value;case"BOOLEAN":return typeof value==="boolean";case"DATETIME":return value instanceof Date;case"BIGINT":return typeof value==="bigint";case"NULL":return value===null}return false};exports.verifyDatatype=verifyDatatype;const serializeData=(serialize,data,isPartial=false)=>{return new Promise((resolve,reject)=>{for(const key in isPartial?data:serialize){if(!(key in data)){if(serialize[key].default!==undefined){data[key]=serialize[key].default}else if(!serialize[key].autoIncrement){return reject(new Error(`Missing column ${key}`))}}if(serialize[key].autoIncrement){delete data[key]}else{if(serialize[key].notNull&&(data[key]===null||data[key]===undefined))return reject(new Error(`Column ${key} cannot be null or undefined`));if(data[key]!==null&&data[key]!==undefined&&!(0,exports.verifyDatatype)(data[key],serialize[key].type))return reject(new Error(`Invalid datatype for column ${key}`));if(data[key]!==null&&data[key]!==undefined&&typeof serialize[key].check==="function"){try{const isValid=serialize[key].check(data[key]);if(isValid instanceof Error)return reject(isValid)}catch(e){const message="message"in e?e.message:"Invalid value, error thrown: "+String(e);return reject(new Error(message))}}}}resolve(data)})};exports.serializeData=serializeData;class Custom{_disconnected=false;database;constructor(database){this.database=this.connect(database)}get disconnected(){return this._disconnected}set disconnected(value){this._disconnected=value;if(value)this.disconnect()}async ready(callback){if(this._disconnected)throw new Error("Database is disconnected");const db=await this.database;return callback?await callback(db):undefined}}exports.Custom=Custom;class Table{custom;name;_disconnected=false;serialize;initialPromise;constructor(custom,name,columns){this.custom=custom;this.name=name;this.serialize=Object.keys(columns).reduce((acc,key)=>{acc[key]={type:(0,exports.getDatatype)(columns[key].type),primaryKey:columns[key].primaryKey??false,autoIncrement:columns[key].autoIncrement??false,notNull:columns[key].notNull??false,default:columns[key].default,unique:columns[key].unique??false,check:columns[key].check};return acc},{});this.initialPromise=this.custom.createTable(name,this.serialize)}async disconnect(){this._disconnected=true}async ready(callback){if(this._disconnected)throw new Error("Database is disconnected");await this.initialPromise;return callback?await callback(this):undefined}getColumnType(key){return this.serialize[key].type}getColumns(){return this.serialize}wheres(...where){return where}selectAll(where,columns){return this.ready(()=>this.custom.selectAll(this.name,columns,where))}selectOne(where,columns){return this.ready(()=>this.custom.selectOne(this.name,columns,where))}selectFirst(by,where,columns){return this.ready(()=>this.custom.selectFirst(this.name,by,columns,where))}selectLast(by,where,columns){return this.ready(()=>this.custom.selectLast(this.name,by,columns,where))}exists(where){return this.ready(async()=>{const data=await this.custom.selectOne(this.name,undefined,where);return data!==null})}async insert(data){data=await(0,exports.serializeData)(this.serialize,data);return this.ready(()=>this.custom.insert(this.name,data))}async update(data,where){data=await(0,exports.serializeData)(this.serialize,data,true);return this.ready(()=>this.custom.update(this.name,data,where))}delete(where){return this.ready(()=>this.custom.delete(this.name,where))}length(where){return this.ready(()=>this.custom.length(this.name,where))}}exports.Table=Table;class Database{database;custom;tables=new Map;constructor(custom,database){this.database=database;this.custom=new custom(database)}async ready(callback){return this.custom.ready(()=>callback?.(this)??Promise.resolve(undefined))}async disconnect(){this.custom.disconnected=true;this.tables.forEach(table=>table.disconnect());this.tables.clear()}forTable(name,columns){return this.ready(()=>{if(this.custom.disconnected)throw new Error("Database is disconnected");let table=this.tables.get(name);if(!table){table=new Table(this.custom,name,columns);this.tables.set(name,table)}return Promise.resolve(table)})}deleteTable(name){return this.ready(async()=>{if(this.custom.disconnected)throw new Error("Database is disconnected");await this.custom.deleteTable(name);this.tables.delete(name)})}deleteDatabase(){return this.ready(async()=>{if(this.custom.disconnected)throw new Error("Database is disconnected");this.custom.disconnected=true;await this.custom.deleteDatabase();this.tables.forEach(table=>table.disconnect());this.tables.clear()})}}exports.Database=Database},{}]},{},[1])(1)});